module myModule;

def dot[T](a: var Vec2[T], b: var Vec2[T]) -> T {
  const result: T = a.x * b.x + a.y * b.y;
  return result;
};

def plus[T](a: var T, b: var T) -> T {
  return a + b;
};

def plus[T](a: var Vec2[T], b: var Vec2[T]) -> Vec2[T] {
  var result: Vec2[T];
  for idx in 0 until 2 {
    at(result, idx) = at(a, idx) + at(b, idx);
  }
  return result;
};

def times[T](a: T, b: T) -> T {
  return a * b;
};

def times[T](a: Vec2[T], scale: T) -> Vec2[T] {
  var result: Vec2[T];
  for idx in 0 until 2 {
    at(result, idx) = times(at(a, idx), b=scale);
  }
  return result;
};

def at[T](self: var Vec2[T], idx: u32) -> var T {
  if idx == 0 {
    return self.x;
  } else {
    return self.y;
  }
};

def sum[T](toSum: var array[8 * 3; Vec2[T]]) -> Vec2[T] {
  var result: Vec2[T];
  for jdx in 0 until 8 * 3 {
    if jdx == 0 {
      for idx in 0 until 2 {
        at(result, idx) = at(toSum(0), idx);
      }
    } else {
      result = plus(a=result, b=toSum(jdx));
    }
  }
  return result;
};

def sum[T](toSum: var openarray[Vec2[T]]) -> Vec2[T] {
  var result: Vec2[T];
  for jdx in 0 until len(toSum) {
    if jdx == 0 {
      for idx in 0 until 2 {
        at(result, idx) = at(toSum(0), idx);
      }
    } else {
      result = plus(result, toSum(jdx));
    }
  }
  return result;
};

struct Aaaa {
  x: T;
};

struct Vec2I32 {
  x: i32;
  y: i32;
};

struct Vec2[T] {
  x: T;
  y: T;
};

struct Vec2Ptr[T] {
  x: ptr T;
  y: ptr T;
};

struct Vec3Arr3Vec2[T] {
  x: array[1 * 3; Vec2[T]];
  y: array[1 * 3; Vec2[T]];
  z: array[1 * 3; Vec2[T]];
};

struct Vec3OarrVec2[T] {
  x: openarray[Vec2[T]];
  y: openarray[Vec2[T]];
  z: openarray[Vec2[T]];
};

struct Vec3Oarr[T] {
};


