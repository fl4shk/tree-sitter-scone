module myModule;

def dot[T](a: var Vec2[T], b: var Vec2[T]) -> T {
  const result: T = a.x * b.x + a.y * b.y;
  #const result: T = a * b;
  return result;
};
def plus[T](a: var Vec2[T], b: var Vec2[T]) -> Vec2[T] {
  var result: Vec2[T];
  for idx in 0 until 2 {
    result.at(idx) = a.at(idx) + b.at(idx);
  }
  return result;
};

def at[T](self: var Vec2[T], idx: u32) -> var T {
  if idx == 0 {
    return self.x;
  } else {
    return self.y;
  }
};
def sum[T](toSum: var array[8 * 3; Vec2[T]]) -> Vec2[T] {
  var result: Vec2[T];

  for jdx in 0 until 8 * 3 {
    if jdx == 0 {
      for idx in 0 until 2 {
        result.at(idx) = toSum(0).at(idx);
      }
    } else {
      result = result.plus(toSum(jdx));
    }
  }
};
def times[T](a: T, b: T) -> T {
  return a * b;
};
def sum[T](toSum: var array[8 * 3; Vec2[T]]) -> Vec2[T] {
  var result: Vec2[T];

  for jdx in 0 until 8 * 3 {
    if jdx == 0 {
      for idx in 0 until 2 {
        result.at(idx) = toSum(0).at(idx);
      }
    } else {
      result = result.plus(toSum(jdx));
    }
  }
};
struct Vec2[T] {
  x: T;
  y: T;
};
